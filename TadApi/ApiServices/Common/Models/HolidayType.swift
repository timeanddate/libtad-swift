//
//  HolidaysHoliday.swift
//
//  Created by Zoltan Tuskes on 26/03/2020.
//  Copyright © 2020 Time and Date. All rights reserved.
//

import Foundation

/// HolidayType
/// - SeeAlso:[HolidayType] (https://services.timeanddate.com/api/doc/v3/type-holiday.html)
public struct HolidayType: Codable {

    /// Identifier for the holiday definition. Please note that this id is not unique, not even with a single year – the same holiday event may be returned multiple time because it is observed on a different day, or because it is scheduled in a different calendar (Hebrew or Muslim calendar) and happens multiple times within a Gregorian year. Use the uid field for purposes where you need a unique identifier.
    public let id: Int!

    /// Id for the shown holiday instance. The id is designed to be unique across all holiday instances generated by the timeanddate.com API services and respects different calendars and other reasons that may cause events to occurs multiple times within one Gregorian year.
    /// Example: 0007d600000007db
    public let uid: String?

    /// Holiday/Observance name.
    public let name: [TextType]!

    /// Date/time of the holiday instance. Most holidays do not have a specific time – in this case the time components will be skipped. Some special events like equinoxes and solstices include the exact time of the event as well, in this case the timestamp will be in local time zone (including time zone data) (countries with multiple time zones: local time in capital city).
    /// - Note: Request version 1 will return time in either local time or UTC (depending on the holiday type) with no time zone information and shall thus no longer be used.
    public let date: TimeType!

    /// Country of the holiday instance. This element is not present in businessdate and businessduration services.
    public let country: Country?

    /// Summary of locations where this holiday instance is valid. This element is not present in businessdate and businessduration services, and only present if the holiday instance does not affect the whole country.
    public let locations: String?

    /// States/subdivisions that are affected by this holiday instance. This element is not present in businessdate and businessduration services, and only present if the holiday instance is not valid in the whole country.
    public let states: HolidayStateType?

    /// A short description of the holiday instance. This element is not present in businessdate and businessduration services.
    public let oneliner: [TextType]?

    /// Classification of the holiday. Most days have only one classification, bust some have multiple types associated. This happens e.g. in conjunction with religious days that also are flag days. This element is not present in businessdate and businessduration services.
    /// Example: National Holiday
    public let types: [String]!

    /// Further information about the specific holiday. The URL points to the timeanddate.com web page.
    /// Example: http://www.timeanddate.com/holidays/us/new-year-day
    public let url: String!

    /// Type: String
    public let urlid: String!

    /// :nodoc:
    enum CodingKeys: String, CodingKey {
        case country = "country"
        case date = "date"
        case id = "id"
        case name = "name"
        case oneliner = "oneliner"
        case types = "types"
        case uid = "uid"
        case url = "url"
        case urlid = "urlid"
        case locations = "locations"
        case states = "states"

    }

    /// :nodoc:
    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        country = try values.decodeIfPresent(Country.self, forKey: .country)
        date = try values.decodeIfPresent(TimeType.self, forKey: .date)
        id = try values.decodeIfPresent(Int.self, forKey: .id)
        name = try values.decodeIfPresent([TextType].self, forKey: .name)
        oneliner = try values.decodeIfPresent([TextType].self, forKey: .oneliner)
        types = try values.decodeIfPresent([String].self, forKey: .types)
        uid = try values.decodeIfPresent(String.self, forKey: .uid)
        url = try values.decodeIfPresent(String.self, forKey: .url)
        urlid = try values.decodeIfPresent(String.self, forKey: .urlid)
        locations = try values.decodeIfPresent(String.self, forKey: .locations)
        states = try values.decodeIfPresent(HolidayStateType.self, forKey: .states)
    }

}
